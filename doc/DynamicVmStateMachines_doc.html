<h1>Dynamic VM provisioning/retirement StateMachine selection</h1>
<p>Within CloudForms,VM StateMachines are defined by default
following the associated request event.</p>
<p>This may be an issue in some cases &nbsp;: 
</p>
<ul>
	<li/>
<p style="margin-bottom: 0cm">&nbsp;Within complex projects,
	several provisioning/retirement context with different workflows,
	constraints or &nbsp;infrastructure tools may exist requiring
	different provisioning/retirement steps on a per item basis.</p>
	<li/>
<p style="margin-bottom: 0cm">A manually provisioned VM will
	not have to use a service ordered VM StateMachine as it have not to
	(or can not) provide specific parameters or comply to this service
	placement constraints..</p>
	<li/>
<p>As several parallel implementations, use cases,
	developments or tests are enabled, each context requires it’s own
	StateMachines that won’t interfere with others concurring enabled
	domains/namespaces at the same time.</p>
</ul>
<p>This component let you define specific StateMachines for both
provisioning and retirement that will not interfere, overload or  be
overloaded due to their domain order of priority. In the datastore 
</p>
<p>Potentially quite any switching criteria available in associated
requests may be chosen and implemented.</p>
<p>This precise implementation case is based on catalog item service
template tagging, that should cover most generic use cases by
default. It is implemented in our team lab and provides the following
advantages&nbsp;:</p>
<ul>
	<li/>
<p>By tagging his case study catalog items with unique tags,
	any of the team member can test quite whatever he wants without any
	impact risks for others, including regular services deployed at
	higher level (i.e. OpenShift services).</p>
	<li/>
<p>This is totally transparent to regular services. If not
	tagged for dynamic state machine election, they will be mapped back
	to default configuration with respect to domain hierarchy.</p>
	<li/>
<p>All tagged case studies can reside at same time in a single
	enabled domains, per user in our case. That drastically reduces the
	number of domains, improve overall management and let’s users have
	all their cases available at the same time. 
	</p>
</ul>
<p>Thereafter come several sections&nbsp;:</p>
<ul>
	<li/>
<p>Using it</p>
	<li/>
<p>Integration context background</p>
	<li/>
<p>Integration details</p>
</ul>
<hr/>

<h2 class="western">Using it</h2>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">From
AutomationBricks</font></font></p>
<p>You will need the following from AutomationBricks seen as first
instances from your datastore hierarchy&nbsp;:</p>
<p style="margin-left: 2cm">/AutomationBricks/Infrastructure/VM/Lifecycle/Provisioning</p>
<p style="margin-left: 2cm">/AutomationBricks/Infrastructure/VM/Lifecycle/Retirement</p>
<p>You will also need
/AutomationBricks/Integration/CustomStateMachines/BySvcTmplTag and
it’s instance and method (<span style="font-weight: normal">GetStateMachine</span>
and get_state_machine) 
</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Create
your and tags</font></font></p>
<p>You have to create 2 tag categories&nbsp;: <span style="font-weight: normal">vm_prov_custom</span>
and <span style="font-weight: normal">vm_ret_custom</span></p>
<p>They will contain StateMachine class names tags.</p>
<p>Within those categories, create tags in snake case containing the
StateMachine class name CamelCase equivalent. In example, for a tag
named <b>dyn_by_tag</b> the target StateMachine class will be
<b>DynByTag</b></p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Create
your custom state machines</font></font></p>
<p>Within your context copy a valid provisioning and retirement
StateMachines in a domain of your choice within your datastore.<br/>
You
will need to copy&nbsp;:</p>
<ul>
	<li/>
<p>the class</p>
	<li/>
<p>the provisioning instance</p>
	<li/>
<p>the update_provision_status or update_retirement_status
	method.</p>
</ul>
<p>Once done, rename the class you just copied in your datastore with
the CamelName matching your snake_case name.</p>
<p>Eventually, edit the update_*_status method so they log the
StateMachine they are in as they are called.</p>
<p>You may find an example of all this with the sample DynByTag
custom state machine used within AutomationBricks. Obviously <b>do
not use it </b>(nor the name). As you will very probably have a
different infrastructure and underlying automation it will simply not
work. It is only included as a sample.</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Create
or choose a service catalog item and tag it</font></font></p>
<p>Create a use a test catalog item service of your choice. Provision
or Retire it (if a vm ever exist from this template). If you look at
evm.log for get_state_machine output you should see it goes through
default provisioning or retirement.</p>
<p>Tag it with any or both of your vm_*_custom tags. Provision or
Retire it (if a vm ever exist from this template). Look at evm.log.
get_state_machine and update_*_status should tell you if you go
through your custom state machine.</p>
<hr/>

<h2 class="western">Integration context background</h2>
<p>As a request event is sent, the initial entry point used to select
the appropriate StateMachine is the class
/Infrastructure/VM/Lifecycle which schema defines an empty list of
states, mainly relationships and methods.<br/>
This class contains
two instances that are of interest in our case&nbsp;: Provisioning
and Retirement . The third one, Migrate, do not enter our current
perimeter but could be integrated as well if required.</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Provisioning</font></font></p>
<p>Here are the states used in Lifecycle/Provisioning instance&nbsp;:
</p>
<p><span id="Frame1" dir="ltr" style="float: left; width: 22.38cm; height: 2.86cm; border: none; padding: 0cm; background: #ffffff">
	<p style="margin-top: 0.21cm; margin-bottom: 0.21cm"><img src="DynamicVmStateMachines_doc_html_437af882840fb6a7.gif" name="Image1" align="bottom" width="100%" border="0"/>

	<font size="3" style="font-size: 12pt"><i>Illustration 1: D</i></font><font size="3" style="font-size: 12pt"><i>efault
	</i></font><font size="3" style="font-size: 12pt"><i>Provisioning
	instance</i></font></p>
</span><br clear="left"><br/>
<br/>

</p>
<p><a name="explorer_title"></a><a name="explorer_title_text"></a>At
state RelationShip5 it calls an instance named from the user group
name within /Infrastructure/VM/Provisioning/Profile class. By
default, the only group that has an instance is
EvmGroup-super_administrator with no specificities from the class
schema, so in most cases it’s the .missing instance that will be
called, identical as well to the class schema by default.<br/>
In
those instances the only step that through the get_state_machine
messasge is the last one :</p>
<p><span id="Frame2" dir="ltr" style="float: left; width: 22.81cm; height: 1.32cm; border: none; padding: 0cm; background: #ffffff">
	<p style="margin-top: 0.21cm; margin-bottom: 0.21cm"><img src="DynamicVmStateMachines_doc_html_cd74f998caf2af63.gif" name="Image2" align="bottom" width="100%" border="0"/>

	<font size="3" style="font-size: 12pt"><i>Illustration 2:
	state_machine state in default Profile instances</i></font></p>
</span><br clear="left"><br/>
<br/>

</p>
<p>We then have the choice to intercept the default provisioning
StateMachine election at two different stages, at the
Lifecycle/Provisioning or at the Profile/.missing stage.<br/>
In both
case we would trigger a dedicated instance so to do the job.<br/>
We
choosed to go for the Lifecycle level for the following reasons&nbsp;:</p>
<ol>
	<li/>
<p>Intercepting at Profile level would mean that we intend to
	use two selection criterias, the user group and the service template
	tag, that is not our case.</p>
	<li/>
<p>Integrating at Profile level would imply changing the Class
	schema, as rather than a parameter we require a relationship entry
	point. That would have an un-necessary structural impact that we
	prefered to avoid as it was possible.</p>
	<li/>
<p>Retirement StateMachine setting/jump is directly done from
	Lifecycle level. We considered that implemeting our case for same
	core functionality (StateMachine election) at two different and
	un-related logical levels (Lifecycle + Profile) would not be a good
	practice as it was not absolutely required.</p>
</ol>
<p>We currently did not meet cases where an implementation of both
filters (user group + dynamic request level parameter) would be
required. In case it would, the instance called at the Lifecycle
level may be simply copied in a new relationship within the Profile
class schema and the state_machine parameter commended or removed.
Our modified Lifecycle/Provisioning instance could then be removed so
to use the default one again.</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Retirement</font></font></p>
<p>Here is the state used in Lifecycle/Retirement default instance&nbsp;:</p>
<p><span id="Frame3" dir="ltr" style="float: left; width: 22.46cm; height: 1.24cm; border: none; padding: 0cm; background: #ffffff">
	<p style="margin-top: 0.21cm; margin-bottom: 0.21cm"><img src="DynamicVmStateMachines_doc_html_2bb80493ab4e0a35.gif" name="Image3" align="bottom" width="100%" border="0"/>
<font size="3" style="font-size: 12pt"><i><span style="display: none"><br/>
</span>Illustration
	1: Default Retirement instance</i></font></p>
</span><br clear="left"><br/>
<br/>

</p>
<p>From that state we directly jump to retirement StateMachine.
Therefore it’s here that we will integrate our modifications.</p>
<hr/>

<h2 class="western">Integration details</h2>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">High
level considerations</font></font></p>
<p>The following was considered&nbsp;:</p>
<ul>
	<li/>
<p>We should have one single instance and method pair for both
	provisioning and retirement. The switch will be done through message
	sending.</p>
	<li/>
<p>In this case we will not use the .missing shortcut to
	method as other use cases could imply schema values modifications</p>
	<li/>
<p>No method hard coding&nbsp;: anything related to context
	(such as default namespaces and class) must come from the instance. 
	</p>
	<li/>
<p>Within the StateMachine election, any non correct dynamic
	StateMachine election should imply switching back to default
	StateMachine.</p>
</ul>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">GetStateMachine
instance</font></font></p>
<p>This case have been implemented in the namespace&nbsp;:
/AutomationBricks/Integration/CustomStateMachines</p>
<p>Tag based election class is&nbsp;: BySvcTmplTag</p>
<p>It currently has a single instance&nbsp;: GetStateMachine</p>
<p><span id="Frame4" dir="ltr" style="float: left; width: 24.13cm; height: 6.43cm; border: none; padding: 0cm; background: #ffffff">
	<p style="margin-top: 0.21cm; margin-bottom: 0.21cm"><img src="DynamicVmStateMachines_doc_html_61c18571e4183898.gif" name="Image4" align="bottom" width="100%" border="0"/>
<font size="3" style="font-size: 12pt"><i><span style="display: none"><br/>
</span>Illustration
	2: GetStateMachine instance schema</i></font></p>
</span><br clear="left"><br/>
<br/>

</p>
<p>Fields are&nbsp;:</p>
<ul>
	<li/>
<p>provision_category&nbsp;: Tag category containing target
	provision StateMachine instance name. See later for tag format.</p>
	<li/>
<p>def_prov_statemachine&nbsp;: Default provisioning
	statemachine to initialize in $evm.root[‘state_machine’] in case
	we need to go back to it. In this instance, initialized at ManageIQ
	domain default value</p>
	<li/>
<p>retire_category&nbsp;: Tag category containing target
	retirement StateMachine instance name. See later for tag format.</p>
	<li/>
<p>def_ret_namespace&nbsp;: Default retirement StateMachine
	namespace – also used to create the dynamic retirement
	StateMachine path. <i>[*]</i></p>
	<li/>
<p>def_ret_class&nbsp;:  Default retirement StateMachine class
	<i>[*]</i></p>
	<li/>
<p>def_ret_instance&nbsp;:  Default retirement StateMachine
	instance - also used to create the dynamic retirement StateMachine
	path. <i>[*]</i></p>
	<li/>
<p>prov_msg&nbsp;: message this instance should receive to
	trigger provision StateMachine election in it’s method. <i>[*]</i></p>
	<li/>
<p>ret_msg&nbsp;: message this instance should receive to
	trigger provision StateMachine election in it’s method. <i>[*]</i></p>
	<li/>
<p>execute&nbsp;: method to execute</p>
</ul>
<p><i>[*] = could be useful to redefine but primarily created to
avoid hard-coding in method.</i></p>
<p style="margin-bottom: 0cm">Messages are&nbsp;:</p>
<ul>
	<li/>
<p style="margin-bottom: 0cm">provision 
	</p>
	<li/>
<p style="margin-bottom: 0cm">retire</p>
</ul>
<p style="margin-bottom: 0cm">Those messages are used within the
execute method to switch between provisioning and retirement
StateMachine.<br/>
They are also used in the instance to activate the
configuration of some parameters. This helps to check which are the
mandatory instance initialization from instance. As well, as a
provisioning parameter has nothing to do in the retirement code, it’s
better to have it undefined (so nil if checked) within that code.</p>
<p style="margin-bottom: 0cm"><br/>

</p>
<p style="margin-top: 0.42cm; font-style: normal; page-break-after: avoid">
<font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">Calling
GetStateMachine instance</font></font></p>
<p style="font-style: normal">As seen from context background, we
will have two entry points</p>
<p style="font-style: normal">For provisioning, within
/AutomationBricks/Infrastructure/VM/Lifecycle/Provisioning we will
call it with a provision message at state Relationship6&nbsp;:</p>
<p style="font-style: normal"><img src="DynamicVmStateMachines_doc_html_d0c09b3b20f39c4b.gif" name="Image5" align="left" width="899" height="110">
  <br clear="left"/>
</img>
<br/>
<br/>

</p>
<p style="font-style: normal">For retirement, within
/AutomationBricks/Infrastructure/VM/Lifecycle/Retirement we will call
it with a retire message at state Relationship4&nbsp;:</p>
<p style="font-style: normal"><img src="DynamicVmStateMachines_doc_html_f38bae85395621e0.gif" name="Image6" align="left" width="898" height="46">
  <br clear="left"/>
</img>
<br/>
<br/>

</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt"><span style="font-style: normal">Tag</span>
Format and target StateMachine names</font></font></p>
<p>Tags used for templates should give the name of the target state
machine. Given restrictions in tags syntax, those tag names are in
snake_case whereas the resulting target StateMachine class name will
be CamelCase.</p>
<p>In example, for a tag named <b>dyn_by_tag</b> the target class
will be <b>DynByTag</b></p>
<p>The target provisioning StateMachine will be&nbsp;:
/Infrastructure/VM/Provisioning/StateMachines/DynByTag/template<br/>
The
target retirement StateMachine will be&nbsp;:
/Infrastructure/VM/Retirement/StateMachines/DynByTag/Default</p>
<p style="margin-top: 0.42cm; page-break-after: avoid"><font face="Albany, sans-serif"><font size="4" style="font-size: 14pt">get_state_machine
method</font></font></p>
<p>It’s objectives are&nbsp;:</p>
<ul>
	<li/>
<p>Identify valid tag categories and messages from instance</p>
	<li/>
<p>Get matching tags on template for current message</p>
	<li/>
<p>If anything is compliant ot custom settings, set custom
	StateMachine class name (if provisioning) or instanciate
	StateMachine instance(if retiring).</p>
	<li/>
<p>If any uncompliance with custom setting, roll back to
	default StateMachine election.  
	</p>
</ul>
<p>Method is well commented (I guess) so should be self
explenatory.<br/>
A global @debug variable is defined as true at it’s
very begining that could be set to false when you won’t need any
verbosity anymore. 
</p>
<hr/>

<p><br/>
<br/>

</p>
<p><br/>
<br/>

</p>
</body>
</html>
