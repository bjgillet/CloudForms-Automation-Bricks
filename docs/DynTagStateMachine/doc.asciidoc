## Dynamic VM provisioning/retirement StateMachine selection

Within CloudForms,VM StateMachines are defined by default following the associated request event.

This may be an issue in some cases :

* Within complex projects, several provisioning/retirement context with different workflows, constraints or infrastructure tools may exist requiring different provisioning/retirement steps on a per item basis.
* A manually provisioned VM will not have to use a service ordered VM StateMachine as it have not to (or can not) provide specific parameters or comply to this service placement constraints...
* As several parallel implementations, use cases, developments or tests are enabled, each context requires it’s own StateMachines that won’t interfere with others concurring enabled domains/namespaces at the same time.

This component let you define specific StateMachines for both provisioning and retirement that will not interfere, overload or be overloaded due to their domain order of priority. 

A lot of criterias are available in associated requests to define such StateMachines selection.

This implementation case is based on catalog item service template tagging, that should cover most use cases by default.

Thereafter are the following sections :

* <<using_it,Using it>>
* <<int_context,Integration context background>>
* <<int_details,Integration details>>


[NOTE]
===============================
*About other components reuse of CustomStateMachine :* 

Within AutomationBricks use cases, this component is used extensively by default.

It is the way components and use cases are built, tested and used simultaneously without impacting any of other use cases and even less their lab environment production.

When default use-cases/components will require it, it will be clearly indicated as well as the obvious way to suppress that coupling, should you require or wish it.

===============================

''''
[[using_it]]
### Using it : A quick start guide

#### Setting up the AutomationBrick components

Import the AutomationBricks domain within your datastore and enable it.
From this domain, you will need the following to be seen as first instances from your datastore hierarchy:

* _/Infrastructure/VM/Lifecycle/Provisioning_
* _/Infrastructure/VM/Lifecycle/Retirement_

Place AutomationBricks accordingly within your datastore hierarchy, eventually copying those specific items within a compliant existing hierarchical domain. *In case you would have overloaded those instances, stop that quick try*. Move to following sections to get informations at how this component was integrated, if you would you like to transpose it to your environment. 

#### Create your categories and tags

You have to create 2 tag categories: 

* _vm_prov_custom_
* _vm_ret_custom_

They will contain StateMachine class names tags.

Within those categories, create tags in *snake_case* containing the StateMachine class name *CamelCase* equivalent. In example, for a tag named _custom_state_machine_ the target StateMachine class will be _CustomStateMachine_

Here is an example of a tagged template to target a StateMachine which class name is _DynByTag_.

image::images/tagged_template.png[Screenshot,800,align="center"]


#### Create your custom state machines

Within your context copy/adapt a valid provisioning and retirement StateMachines in a domain of your choice within your datastore.

You will need to create/copy :

* the class within it's orignal tree.
* related instance
* related update_provision_status or update_retirement_status method.

Once done, rename the class you just copied in your datastore with the CamelName matching your snake_case tag name.

Here is a simple snapshot of a test domain custom classes setup, containing the _DynByTag_ StateMachine entry point for both proviosioning and retirement :

image::images/tst_datastore_domain.png[Screenshot,365,align="center"]

Eventually, edit the _update_*_status_ methods so they log their current StateMachine as they are executed. In example, add the following to the methods code :

[source,ruby]
----
$evm.log(:info,"=> Current StateMachine : #{$evm.current_namespace}/#{$evm.current_class}/#{$evm.current_instance}")
----

#### Create or choose a service catalog item and tag it

* Create or use a test catalog item service of your choice that you know and tested to work without this brick. 
Provision or Retire it (if a vm ever exist from this template). If you look at _evm.log_ for _get_state_machine_ output you should see it goes through default provisioning or retirement.
* Tag the provisioning template with any or both of your _vm_*_custom_ tags. Provision or Retire it (if a vm ever exist from this template). Look at evm.log. _get_state_machine_ and _update_*_status_ should tell you as you go through your custom state machine.

''''

[[int_context]]
### Integration context background

As a request event is sent, the initial entry point used to select the appropriate StateMachine is the class _/Infrastructure/VM/Lifecycle_ which _schema_ defines an empty list of states, mainly relationships and methods.

This class contains two instances that are of interest in our case : _Provisioning_ and _Retirement_ . The third one, _Migrate_, do not enter in our current perimeter.

#### Provisioning

Here are the states used in Lifecycle/Provisioning instance : 

image::images/def_lifecycle_prov_state.gif[Screenshot,800,align="center"]


At state _RelationShip5_ it calls an instance named from the user group name within _/Infrastructure/VM/Provisioning/Profile_ class, trnasmitting the message _get_state_machine_. 

By default, the only group that has an instance is _EvmGroup-super_administrator_ with no specificities from the class schema, so in most cases it’s the _.missing_ instance that will be called, identical as well to the class schema by default.
In those instances the only step that is triggered on the _get_state_machine_ message is the last one :

image::images/def_profile_prov-state.gif[Screenshot,800,align="center"]

We then have the choice to intercept the default provisioning StateMachine election at two different stages, at the _Lifecycle/Provisioning_ or at the _Profile/.missing_ stage.
In both case we would trigger a dedicated instance to do the job.

We choosed to go for the _Lifecycle_ level for the following reasons:

* Intercepting at Profile level would mean that we intend to use two selection criterias, the user group and the service template tag, that is not our case.
* Integrating at Profile level would imply changing the Class schema, as rather than a parameter we require a relationship entry point. That would have an un-necessary structural impact that we prefered to avoid as it was possible.
* Selecting a StateMachine sounded more appropriate from a provisioning/retirement template or workflow standpoint than from a user group ownership standpoint (after all, we provision VMs, not users...)
* Retirement StateMachine setting/jump is directly done from Lifecycle level. We considered that implemeting our case for same core functionality (StateMachine election) at two different and un-related logical levels (Lifecycle + Profile) would not be a good practice as it was not absolutely required.

So far, we did not meet cases where an implementation of both filters (user group + dynamic request level parameter) would be required. In case it would, the instance called at the Lifecycle level may be simply copied in a new relationship within the _Profile_ class schema and the _state_machine_ parameter commented or removed. Our modified _Lifecycle/Provisioning_ instance could then be removed.

#### Retirement

Here is the state used in Lifecycle/Retirement default instance :

image::images/def_lifecycle_ret_state.gif[Screenshot,800,align="center"]

From that state we directly jump to retirement StateMachine. Therefore it’s here that we will set our entry point.


''''
[[int_details]]
### Integration details

#### Global considerations

* We should have one single instance and method pair for both provisioning and retirement. The switch will be done through message sending.
* In this case we will not use the _.missing_ shortcut to method as other use cases could imply schema values modifications
* Avoid method hard coding as possible : anything related to context (such as default namespaces and class) must come from the instance. 
* Within the StateMachine election, any non correct dynamic StateMachine election behavior should imply switching back to default StateMachine.

#### GetStateMachine instance

This case have been implemented as follows.

* *Namespace* : _/AutomationBricks/Integration/CustomStateMachines_
* *Class* : _BySvcTmplTag_
* *Instance*: _GetStateMachine_

thereafter is the schema information as filled in within instance :

image::images/GetStateMachine_schema.gif[Screenshot,800,align="center"]

Fields are:

* *provision_category*: Tag category containing target provision StateMachine instance name. See later for tag format.
* *def_prov_statemachine*: Default provisioning statemachine to initialize in $evm.root[‘state_machine’] in case we need to go back to it. In this instance, initialized at ManageIQ domain default value
* *retire_category*: Tag category containing target retirement StateMachine instance name. See later for tag format.
* *def_ret_namespace*: Default retirement StateMachine namespace – also used to create the dynamic retirement StateMachine path. _[*]_
* *def_ret_class*: Default retirement StateMachine class _[*]_
* *def_ret_instance*: Default retirement StateMachine instance - also used to create the dynamic retirement StateMachine path. _[*]_
* *prov_msg*: message this instance should receive to trigger provision StateMachine election in it’s method. _[*]_
* *ret_msg*: message this instance should receive to trigger provision StateMachine election in it’s method. _[*]_
* *execute*: method to execute

_[*] = could be useful to redefine but primarily created to avoid hard-coding in method._

So far, valid messages are:

* *provision* 
* *retire*

Those messages are used within the execute method to switch between provisioning and retirement StateMachine.

They are also used in the instance to activate the configuration of some parameters. This helps to check which are the mandatory instance initialization from instance. As well, as a provisioning parameter has nothing to do in the retirement code, it’s better to have it undefined (so nil if checked) within that code.

#### Calling GetStateMachine instance

As seen from context background, we will have two entry points. 

For provisioning, within _/AutomationBricks/Infrastructure/VM/Lifecycle/Provisioning_ we will call it with a _provision_ message at state _Relationship6_:

image::images/mod_lifecycle_prov_state.gif[Screenshot,800, align="center"]

For retirement, within _/AutomationBricks/Infrastructure/VM/Lifecycle/Retirement_ we will call it with a _retire_ message at state _Relationship4_ :

image::images/mod_lifecycle_ret_state.gif[Screenshot,800,align="center"]

#### Tag Format and target StateMachine names

Tags used for templates should give the name of the target state machine. 

Due to restrictions in tags syntax, those tag names are in snake_case whereas the resulting target StateMachine class name will be CamelCase.

In example, for a tag named dyn_by_tag the target class will be DynByTag

* The target provisioning StateMachine will be : _/Infrastructure/VM/Provisioning/StateMachines/DynByTag/Template_
* The target retirement StateMachine will be: _/Infrastructure/VM/Retirement/StateMachines/DynByTag/Default_

#### get_state_machine method

This method is the only one from that case and is fairly simple.

It’s objectives are :

* Identify valid tag categories and messages from instance
* Get matching tags on template for current message
*  If anything is compliant ot custom settings, set custom StateMachine class name (if provisioning) or instanciate StateMachine instance(if retiring).
* If any uncompliance with custom setting, roll back to default StateMachine election. 

Method is well commented (I guess) so should be self explenatory.

A global @debug variable is defined as true at it’s very begining that could be set to false when you won’t need any verbosity anymore. 

''''
